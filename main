#!/usr/bin/python3
from Candidate import Candidate
from Employee import Employee
from Game import Game
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

import datetime
import gspread
import smtplib
import ssl
import time


today = int(datetime.datetime.now().strftime('%j'))
year = int(datetime.datetime.now().year)
test_email = 'dylan.doyle11@gmail.com'


def sheetconnect():
    #Connecting to the Google API and the spreadsheet being used using credentials from JSON file
    try:
        from oauth2client.service_account import ServiceAccountCredentials
        scope = ['https://spreadsheets.google.com/feeds', 'https://www.googleapis.com/auth/drive']
        creds = ServiceAccountCredentials.from_json_keyfile_name('/home/pi/Desktop/Python/Bot/bot_cred.json', scope)
        client = gspread.authorize(creds)
        #Creating global variable 'sheet' and giving it all the information from sheet 1 of the spreadsheet
        global sheet
        sheet = client.open("Candidate Tracker").sheet1
        # backup_sheet = client.open("Candidate Tracker Database").sheet1
    except:
        print('Failed to connect. Retrying in 10 seconds')
        time.sleep(10)
        pass
    
class Main:
    #Spreadsheet uses employee initials for ease. Allows for conversion to list employee first names.
    employee_dict = {
        'AA': 'April',
        'GO': 'Gaby'
    }

    def __init__(self):
        self.candidates = []
        self.employees = []
        self.__gen_employees()
        self.email_list = []

    def __gen_employees(self):
        #Creating employees with given information
        self.employees.append(Employee('April', 'april.anolin@kellyservices.com'))
        self.employees.append(Employee('Gaby', 'gabriela.ong@kellyservices.com'))

    def notifymaster(self):
    #The following method sends creator an email to test functionality
        password = 'Dylandylan2'
        sent_from = 'kellyservices.bot@gmail.com'
        to = [test_email]
        subject = 'RUN'
        body = 'RUN'

        msg = MIMEMultipart()
        msg['To'] = ', '.join(to)
        msg['From'] = sent_from
        msg['Subject'] = subject
        msg.attach(MIMEText(body, 'plain'))

        context = ssl.create_default_context()
        with smtplib.SMTP_SSL("smtp.gmail.com", 465, context=context) as server:
            server.login(sent_from, password)
            server.sendmail(sent_from, to, msg.as_string())

    def sendemail(self):
    #After creating a list of candidates, method gets those candidates and creates an email
    #with respective information and employee handler.
    
        for candidate in self.email_list:
            password = 'Dylandylan2'
            sent_from = 'kellyservices.bot@gmail.com'
            to = [candidate.handler_email]
            subject = ('Assignment Completion - {}, {}'.format(candidate.l_name, candidate.name))
            body = ('Hi {}! Your candidate {}, {} will reach the end of their assignment in {} days.'.format(
                candidate.handler, candidate.l_name, candidate.name, candidate.end))
           #Using python library to create email
            msg = MIMEMultipart()
            msg['To'] = ', '.join(to)
            msg['From'] = sent_from
            msg['Subject'] = subject
            msg.attach(MIMEText(body, 'plain'))
            #Log into email and send using above information
            context = ssl.create_default_context()
            with smtplib.SMTP_SSL("smtp.gmail.com", 465, context=context) as server:
                server.login(sent_from, password)
                server.sendmail(sent_from, to, msg.as_string())

    def run(self):
        #Due to the query limits on Google API, the process can sometimes fail. Scraping process
        #is stopped then continued after 10 seconds whenever there is a break in service. Finishes
        #when 'complete' is True.
        
        complete = False
        place_holder = 1
        while complete is False:
            print('Scraping data...')
            try:
                for i in range(place_holder, len(sheet.col_values(1))):
                    place_holder += 1
                    if i % 10 == 0:
                        print('...')
                    extract_row = sheet.row_values(i + 1)
                    try:
                        #Rearranging the string from spreadsheet to be used in datetime method. If entry is 
                        #contains no integers or is not formatted properly, skip. 
                        end_date = extract_row[0]
                        end_date = end_date.split('/')
                        end_date = [int(i) for i in end_date]
                        end_date.insert(0, end_date[-1])
                        end_date.pop(-1)
                        end_day = int(datetime.datetime(end_date[0], end_date[1], end_date[2]).strftime('%j'))
                    except:
                        pass

                    # Simulate end condition for testing
                    # if i == 50:
                    # end_day = today + 2
                    # if i == 1:
                    # end_day = today + 3
                    
                    #Sending end condition that 2 days is the threshold to send email notice
                    if end_day - today == 2 and end_date[0] == year:
                        print('Assignment end detected')
                        end = end_day - today
                        handler = self.employee_dict[extract_row[1]]
                        # If candidate split between two people i.e 'AA/GO' then take first employee
                        if len(handler) > 2:
                            handler_split = handler.split('/')
                            handler = handler_split[0]
                        #Checking candidate info for handler and setting email of respective employee
                        for employee in self.employees:
                            if handler == employee.name:
                                self.email_list.append(
                                    Candidate(handler, employee.email, extract_row[3], extract_row[2], end))
                                print("Candidate added!")
                complete = True
            except:
                print('Scraping interrupted. Retrying in 10 seconds')
                time.sleep(10)
                pass

        print('Scraping Complete!')
        
        #If a candidate has been added to the list, then send out email.
        if len(self.email_list) > 0:
            try:
                print('Sending out emails')
                self.sendemail()
                print('Email(s) sent! End of program.')
            except:
                print('Failed to send email! End of program.')
        else:
            print('No approaching assignment completion. End of program.')

#Initialize bot, connect sheet, then run the bot.
bot1 = Main()
sheetconnect()
bot1.run()
exit()
